1. Módulo de Parsing y Análisis Léxico
Funciones principales:

parse()
get_tokens()
check_line()
squish_args()
type_arg()
quotes()
is_sep(), ignore_sep()

Responsabilidades:

Leer la entrada del usuario (usando readline)
Tokenizar la línea de comandos
Analizar la sintaxis
Manejar las comillas y caracteres de escape

2. Módulo de Ejecución de Comandos
Funciones principales:

exec_cmd()
exec_bin()
get_the_path()
create_children()
redir_and_exec()

Responsabilidades:

Buscar ejecutables en el PATH
Crear procesos hijos (fork)
Ejecutar comandos con execve
Manejar códigos de retorno

3. Módulo de Builtins
Funciones principales:

ft_echo()
ft_cd()
ft_pwd()
ft_export()
ft_unset()
ft_exit()
is_a_builtins()

Responsabilidades:

Implementar los comandos internos del shell

4. Módulo de Gestión de Variables de Entorno
Funciones principales:

env_init()
secret_env_init()
env_add()
get_env_value()
ft_env()
env_to_str()
print_sorted_env()

Responsabilidades:

Inicializar y gestionar las variables de entorno
Manejar la expansión de variables ($VAR)

5. Módulo de Redirecciones y Pipes
Funciones principales:

redir()
input()
mspipe()
heredoc()

Responsabilidades:

Implementar redirecciones (<, >, >>, <<)
Manejar los pipes (|)
Gestionar los heredocs

6. Módulo de Gestión de Señales y Control
Funciones principales:

sig_init()
sig_int()
sig_quit()

Responsabilidades:

Manejar señales (CTRL+C, CTRL+D, CTRL+)

7. Módulo de Gestión de Memoria y Utilidades
Funciones principales:

free_token()
free_env()
free_tab()
reset_std()
reset_fds()
close_fds()
Funciones de utilidades para tokens (next_sep(), next_run(), etc.)

Responsabilidades:

Liberar memoria
Gestionar descriptores de archivo
Funciones auxiliares

Sugerencia para asignación de trabajo
Si tienes 2 personas:

Persona 1: Módulos 1, 3 y 6 (Parsing, Builtins, Señales)
Persona 2: Módulos 2, 4, 5 y 7 (Ejecución, Variables, Redirecciones, Utilidades)

Fase de diseño:

Asegúrense de comprender completamente las estructuras de datos
Revisen juntos cómo se relacionan las diferentes partes del programa


Fase de esqueleto:

Implementen primero un esqueleto de todas las funciones para que el programa compile
Enfóquense en la estructura básica sin toda la funcionalidad


Fase de implementación incremental:

Comiencen con la implementación de comandos simples (sin pipes ni redirecciones)
Añadan builtins básicos (echo, pwd)
Implementen pipes
Añadan redirecciones
Implementen el resto de builtins
Añadan características avanzadas (expansión de variables, señales, etc.)


Fase de integración y pruebas:

Prueben cada componente individualmente
Integren gradualmente y prueben combinaciones de funcionalidades



Este enfoque modular facilitará la colaboración y permitirá desarrollar y probar cada parte de forma independiente antes de integrarla.